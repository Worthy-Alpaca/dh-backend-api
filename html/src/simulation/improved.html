<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.simulation.improved API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.simulation.improved</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math
import sys
import os
import itertools
import time as tm
from typing import Union
import pandas as pd
from collections import deque
from pathlib import Path
import concurrent.futures

PACKAGE_PARENT = &#34;../&#34;
SCRIPT_DIR = os.path.dirname(
    os.path.realpath(os.path.join(os.getcwd(), os.path.expanduser(__file__)))
)
sys.path.append(os.path.normpath(os.path.join(SCRIPT_DIR, PACKAGE_PARENT)))
from simulation.machine import Machine

global XMOD
XMOD = 1
RANDOM_PROBLEMS = (0, 0)
DROPOFF = 0.1
PICKUP = 0.1


class ManufacturingImproved:
    def __init__(self, data: tuple, machine: Machine) -&gt; object:
        self.machine = machine
        self.components: pd.DataFrame = data[1]
        self.data: pd.DataFrame = data[0]
        self.offsets: pd.DataFrame = data[2]

        if machine.offsets is not None:
            self.OFFSET_X = machine.offsets[&#34;pcb&#34;][0]
            self.OFFSET_Y = machine.offsets[&#34;pcb&#34;][1]
            self.CHECKPOINT = (
                machine.offsets[&#34;checkpoint&#34;][0],
                machine.offsets[&#34;checkpoint&#34;][1],
            )
            self.feedercarts = {}
            for machine in machine.offsets[&#34;feedercarts&#34;]:
                for key in machine:
                    self.feedercarts[key] = machine[key]

    def __call__(
        self, mulitPickOption: bool = True, plotPCB: bool = False
    ) -&gt; Union[float, dict]:
        self.multiPickOption = mulitPickOption
        time = int
        plotX = list
        plotY = list
        start_time = tm.time()
        results = list
        with concurrent.futures.ThreadPoolExecutor() as executer:
            for i in self.offsets:
                results.append(executer.submit(self.calcTime, i))

        for f in results:
            iter_data = f.result()
            time = time + iter_data[&#34;time&#34;]
            plotX.append(iter_data[&#34;plot_x&#34;])
            plotY.append(iter_data[&#34;plot_y&#34;])

        print(&#34;---- Runtime: %s seconds ----&#34; % (tm.time() - start_time))
        if plotPCB == True:
            return {
                &#34;time&#34;: time,
                &#34;plot_x&#34;: list(itertools.chain.from_iterable(plotX)),
                &#34;plot_y&#34;: list(itertools.chain.from_iterable(plotY)),
            }
        return time

    def coating(self):
        &#34;&#34;&#34;simulates the time for coating a PCB&#34;&#34;&#34;
        velocity = 20  # mm/s
        offset = max(self.offsets)
        highestPoint = self.data[&#34;Y&#34;].max() + offset[1]
        return math.sqrt(0**2 + highestPoint**2) / velocity

    def __calcVector(self, vectorA: tuple, vectorB: tuple, velocity: float):
        &#34;&#34;&#34;
        Calculates the time between two given vectors with a given velocity
        - vectorA: Startpoint Location vector
        - vectorB: Endpoint Location vector
        - velocity: Travel velocity given in mm/s
        &#34;&#34;&#34;
        vector_AB = (
            (float(vectorB[0]) - float(vectorA[0])),
            (float(vectorB[1]) - float(vectorA[1])),
        )
        path_length = math.sqrt(vector_AB[0] ** 2 + vector_AB[1] ** 2)
        return path_length / velocity

    def calcTime(self, offset_row: tuple, multiPickOption: bool = True):
        &#34;&#34;&#34;
        Calculates the assembly time for a given offset
        &#34;&#34;&#34;

        TIME = int
        plotting_x = list
        plotting_y = list
        mulitPick = deque()

        for index, row in self.data.iterrows():

            lookupTable = self.components[self.components[&#34;index&#34;].str.match(row.Code)]

            cart_coordinates = self.feedercarts[lookupTable.FeedStyle.max()]

            location_vectorA = (
                int(cart_coordinates[0]) + (lookupTable.ST_No.max() * 20),
                int(cart_coordinates[1]),
            )

            location_vectorB = (
                (row.X + self.OFFSET_X + offset_row[0]),
                (row.Y + self.OFFSET_Y + offset_row[1]),
            )

            plot_coordinates = ((row.X + offset_row[0]), (row.Y + offset_row[1]))

            velocity = lookupTable.mean_acceleration.max()

            DROPOFF = (lookupTable.Dropff.max() / 1000) * 0.1

            if multiPickOption == False:
                path_length = self.__calcVector(
                    location_vectorA, self.CHECKPOINT, velocity
                )
                checkpoint = self.__calcVector(
                    self.CHECKPOINT, location_vectorB, velocity
                )
                TIME = path_length + checkpoint + DROPOFF + TIME

                next_index = index + 1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.simulation.improved.ManufacturingImproved"><code class="flex name class">
<span>class <span class="ident">ManufacturingImproved</span></span>
<span>(</span><span>data: tuple, machine: simulation.machine.Machine)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ManufacturingImproved:
    def __init__(self, data: tuple, machine: Machine) -&gt; object:
        self.machine = machine
        self.components: pd.DataFrame = data[1]
        self.data: pd.DataFrame = data[0]
        self.offsets: pd.DataFrame = data[2]

        if machine.offsets is not None:
            self.OFFSET_X = machine.offsets[&#34;pcb&#34;][0]
            self.OFFSET_Y = machine.offsets[&#34;pcb&#34;][1]
            self.CHECKPOINT = (
                machine.offsets[&#34;checkpoint&#34;][0],
                machine.offsets[&#34;checkpoint&#34;][1],
            )
            self.feedercarts = {}
            for machine in machine.offsets[&#34;feedercarts&#34;]:
                for key in machine:
                    self.feedercarts[key] = machine[key]

    def __call__(
        self, mulitPickOption: bool = True, plotPCB: bool = False
    ) -&gt; Union[float, dict]:
        self.multiPickOption = mulitPickOption
        time = int
        plotX = list
        plotY = list
        start_time = tm.time()
        results = list
        with concurrent.futures.ThreadPoolExecutor() as executer:
            for i in self.offsets:
                results.append(executer.submit(self.calcTime, i))

        for f in results:
            iter_data = f.result()
            time = time + iter_data[&#34;time&#34;]
            plotX.append(iter_data[&#34;plot_x&#34;])
            plotY.append(iter_data[&#34;plot_y&#34;])

        print(&#34;---- Runtime: %s seconds ----&#34; % (tm.time() - start_time))
        if plotPCB == True:
            return {
                &#34;time&#34;: time,
                &#34;plot_x&#34;: list(itertools.chain.from_iterable(plotX)),
                &#34;plot_y&#34;: list(itertools.chain.from_iterable(plotY)),
            }
        return time

    def coating(self):
        &#34;&#34;&#34;simulates the time for coating a PCB&#34;&#34;&#34;
        velocity = 20  # mm/s
        offset = max(self.offsets)
        highestPoint = self.data[&#34;Y&#34;].max() + offset[1]
        return math.sqrt(0**2 + highestPoint**2) / velocity

    def __calcVector(self, vectorA: tuple, vectorB: tuple, velocity: float):
        &#34;&#34;&#34;
        Calculates the time between two given vectors with a given velocity
        - vectorA: Startpoint Location vector
        - vectorB: Endpoint Location vector
        - velocity: Travel velocity given in mm/s
        &#34;&#34;&#34;
        vector_AB = (
            (float(vectorB[0]) - float(vectorA[0])),
            (float(vectorB[1]) - float(vectorA[1])),
        )
        path_length = math.sqrt(vector_AB[0] ** 2 + vector_AB[1] ** 2)
        return path_length / velocity

    def calcTime(self, offset_row: tuple, multiPickOption: bool = True):
        &#34;&#34;&#34;
        Calculates the assembly time for a given offset
        &#34;&#34;&#34;

        TIME = int
        plotting_x = list
        plotting_y = list
        mulitPick = deque()

        for index, row in self.data.iterrows():

            lookupTable = self.components[self.components[&#34;index&#34;].str.match(row.Code)]

            cart_coordinates = self.feedercarts[lookupTable.FeedStyle.max()]

            location_vectorA = (
                int(cart_coordinates[0]) + (lookupTable.ST_No.max() * 20),
                int(cart_coordinates[1]),
            )

            location_vectorB = (
                (row.X + self.OFFSET_X + offset_row[0]),
                (row.Y + self.OFFSET_Y + offset_row[1]),
            )

            plot_coordinates = ((row.X + offset_row[0]), (row.Y + offset_row[1]))

            velocity = lookupTable.mean_acceleration.max()

            DROPOFF = (lookupTable.Dropff.max() / 1000) * 0.1

            if multiPickOption == False:
                path_length = self.__calcVector(
                    location_vectorA, self.CHECKPOINT, velocity
                )
                checkpoint = self.__calcVector(
                    self.CHECKPOINT, location_vectorB, velocity
                )
                TIME = path_length + checkpoint + DROPOFF + TIME

                next_index = index + 1</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="src.simulation.improved.ManufacturingImproved.calcTime"><code class="name flex">
<span>def <span class="ident">calcTime</span></span>(<span>self, offset_row: tuple, multiPickOption: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the assembly time for a given offset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calcTime(self, offset_row: tuple, multiPickOption: bool = True):
    &#34;&#34;&#34;
    Calculates the assembly time for a given offset
    &#34;&#34;&#34;

    TIME = int
    plotting_x = list
    plotting_y = list
    mulitPick = deque()

    for index, row in self.data.iterrows():

        lookupTable = self.components[self.components[&#34;index&#34;].str.match(row.Code)]

        cart_coordinates = self.feedercarts[lookupTable.FeedStyle.max()]

        location_vectorA = (
            int(cart_coordinates[0]) + (lookupTable.ST_No.max() * 20),
            int(cart_coordinates[1]),
        )

        location_vectorB = (
            (row.X + self.OFFSET_X + offset_row[0]),
            (row.Y + self.OFFSET_Y + offset_row[1]),
        )

        plot_coordinates = ((row.X + offset_row[0]), (row.Y + offset_row[1]))

        velocity = lookupTable.mean_acceleration.max()

        DROPOFF = (lookupTable.Dropff.max() / 1000) * 0.1

        if multiPickOption == False:
            path_length = self.__calcVector(
                location_vectorA, self.CHECKPOINT, velocity
            )
            checkpoint = self.__calcVector(
                self.CHECKPOINT, location_vectorB, velocity
            )
            TIME = path_length + checkpoint + DROPOFF + TIME

            next_index = index + 1</code></pre>
</details>
</dd>
<dt id="src.simulation.improved.ManufacturingImproved.coating"><code class="name flex">
<span>def <span class="ident">coating</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>simulates the time for coating a PCB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coating(self):
    &#34;&#34;&#34;simulates the time for coating a PCB&#34;&#34;&#34;
    velocity = 20  # mm/s
    offset = max(self.offsets)
    highestPoint = self.data[&#34;Y&#34;].max() + offset[1]
    return math.sqrt(0**2 + highestPoint**2) / velocity</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.simulation" href="index.html">src.simulation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.simulation.improved.ManufacturingImproved" href="#src.simulation.improved.ManufacturingImproved">ManufacturingImproved</a></code></h4>
<ul class="">
<li><code><a title="src.simulation.improved.ManufacturingImproved.calcTime" href="#src.simulation.improved.ManufacturingImproved.calcTime">calcTime</a></code></li>
<li><code><a title="src.simulation.improved.ManufacturingImproved.coating" href="#src.simulation.improved.ManufacturingImproved.coating">coating</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>